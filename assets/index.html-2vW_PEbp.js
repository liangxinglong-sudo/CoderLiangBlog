import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as p,d as a}from"./app-CFCE3pVF.js";const n={},o=a('<h1 id="《effective-java》读书笔记" tabindex="-1"><a class="header-anchor" href="#《effective-java》读书笔记"><span>《Effective Java》读书笔记</span></a></h1><h2 id="一、创建和销毁对象" tabindex="-1"><a class="header-anchor" href="#一、创建和销毁对象"><span>一、创建和销毁对象</span></a></h2><p>1.用静态工厂方法代替构造器</p><p>2.遇到多个构造器参数时要考虑使用构建器</p><p>3.用私有构造器或者枚举类型强化Singleton属性</p><p>4.通过私有构造器强化不可实例化的能力</p><p>5.优先考虑依赖注入来引用资源</p><p>6.避免创建不必要的对象</p><p>7.消除过期的对象引用</p><p>8.避免使用终结方法和清除方法</p><p>9.try-with-resources优先于try-finally</p><h2 id="二、对于所有对象都通用的方法" tabindex="-1"><a class="header-anchor" href="#二、对于所有对象都通用的方法"><span>二、对于所有对象都通用的方法</span></a></h2><p>1.覆盖equals时请遵守通用约定</p><p>2.覆盖equals时总要覆盖hashCode</p><p>3.始终要覆盖toString</p><p>4.谨慎的覆盖clone</p><p>5.考虑实现Comparable接口</p><h3 id="三、类和接口" tabindex="-1"><a class="header-anchor" href="#三、类和接口"><span>三、类和接口</span></a></h3><p>1.使类和成员的可访问性最小化</p><p>2.要在公有类而非公有域中使用访问方法</p><p>3.使可变性最小化</p>',21),r=[o];function i(l,s){return p(),t("div",null,r)}const d=e(n,[["render",i],["__file","index.html.vue"]]),g=JSON.parse('{"path":"/tools/","title":"工具类","lang":"zh-CN","frontmatter":{"title":"工具类","icon":"toolbox","category":["tools"],"tag":["工具类"],"description":"《Effective Java》读书笔记 一、创建和销毁对象 1.用静态工厂方法代替构造器 2.遇到多个构造器参数时要考虑使用构建器 3.用私有构造器或者枚举类型强化Singleton属性 4.通过私有构造器强化不可实例化的能力 5.优先考虑依赖注入来引用资源 6.避免创建不必要的对象 7.消除过期的对象引用 8.避免使用终结方法和清除方法 9.try...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/tools/"}],["meta",{"property":"og:site_name","content":"CODER LIANG"}],["meta",{"property":"og:title","content":"工具类"}],["meta",{"property":"og:description","content":"《Effective Java》读书笔记 一、创建和销毁对象 1.用静态工厂方法代替构造器 2.遇到多个构造器参数时要考虑使用构建器 3.用私有构造器或者枚举类型强化Singleton属性 4.通过私有构造器强化不可实例化的能力 5.优先考虑依赖注入来引用资源 6.避免创建不必要的对象 7.消除过期的对象引用 8.避免使用终结方法和清除方法 9.try..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Coder Liang"}],["meta",{"property":"article:tag","content":"工具类"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"工具类\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Coder Liang\\",\\"url\\":\\"https://blog.csdn.net/Phone_1070333541?type=blog\\"}]}"]]},"headers":[{"level":2,"title":"一、创建和销毁对象","slug":"一、创建和销毁对象","link":"#一、创建和销毁对象","children":[]},{"level":2,"title":"二、对于所有对象都通用的方法","slug":"二、对于所有对象都通用的方法","link":"#二、对于所有对象都通用的方法","children":[{"level":3,"title":"三、类和接口","slug":"三、类和接口","link":"#三、类和接口","children":[]}]}],"git":{},"readingTime":{"minutes":0.84,"words":253},"filePathRelative":"tools/README.md","excerpt":"\\n<h2>一、创建和销毁对象</h2>\\n<p>1.用静态工厂方法代替构造器</p>\\n<p>2.遇到多个构造器参数时要考虑使用构建器</p>\\n<p>3.用私有构造器或者枚举类型强化Singleton属性</p>\\n<p>4.通过私有构造器强化不可实例化的能力</p>\\n<p>5.优先考虑依赖注入来引用资源</p>\\n<p>6.避免创建不必要的对象</p>\\n<p>7.消除过期的对象引用</p>\\n<p>8.避免使用终结方法和清除方法</p>\\n<p>9.try-with-resources优先于try-finally</p>\\n<h2>二、对于所有对象都通用的方法</h2>\\n<p>1.覆盖equals时请遵守通用约定</p>","autoDesc":true}');export{d as comp,g as data};

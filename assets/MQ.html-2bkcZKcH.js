import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,d as r,o as a}from"./app-CyOKwk5-.js";const n={};function c(i,e){return a(),t("div",null,e[0]||(e[0]=[r(`<h1 id="mq" tabindex="-1"><a class="header-anchor" href="#mq"><span>MQ</span></a></h1><h2 id="什么是消息队列" tabindex="-1"><a class="header-anchor" href="#什么是消息队列"><span>什么是消息队列？</span></a></h2><blockquote><p>维基百科: 在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。</p></blockquote><p>简单概括就是：消息队列就是使用队列来通信的组件。</p><h2 id="为什么需要消息队列" tabindex="-1"><a class="header-anchor" href="#为什么需要消息队列"><span>为什么需要消息队列？</span></a></h2><p>从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要某个东西用来应用解耦服务之间的关系，控制资源合理和时的使用以及缓冲流量高峰等等。 所以消息队列就这么诞生了，常用于：<strong>异步处理</strong>、<strong>服务解耦</strong>、<strong>流量控制</strong>。</p><h4 id="异步处理" tabindex="-1"><a class="header-anchor" href="#异步处理"><span>异步处理</span></a></h4><p><strong>请求链路越来越长</strong>。调用链路长了，响应就慢了，对于一些不需要及时响应的服务，扔到消息队列中就可以直接返回结果了。所以消息队列可以减少请求的等待时间，让服务异步处理，提升系统的总体性能。</p><h4 id="服务解耦" tabindex="-1"><a class="header-anchor" href="#服务解耦"><span>服务解耦</span></a></h4><p>当业务扩张，下游系统不断增加，为了迎合下游系统原系统需要不断的修改，任何一个系统接口的变更都会影响原服务，所以一本都会使用消息队列来解决系统至今的耦合问题，原系统将相关消息放入消息队列中，下游系统需要就去订阅这个主题。</p><h4 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>流量控制</span></a></h4><ol><li>一些秒杀活动爆发式的流量可能系统会顶不住。</li><li>某个服务请求过来后，后端的处理的流程复杂且长</li></ol><p>上述两种情况分别对应生产者过快和消费者过慢的问题，消息队列都能很好的解决上述问题。</p><h4 id="注意" tabindex="-1"><a class="header-anchor" href="#注意"><span>注意</span></a></h4><p>引入消息队列固然有以上的好处，但是多引入一个中间件系统稳定性就下降一层，运维难度就上升一层。</p><h2 id="消息队列两种模型" tabindex="-1"><a class="header-anchor" href="#消息队列两种模型"><span>消息队列两种模型</span></a></h2><p>消息队列有两种模型：队列模型和发布/订阅模型</p><h4 id="队列模型" tabindex="-1"><a class="header-anchor" href="#队列模型"><span>队列模型</span></a></h4><p>一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，即一个消息只能被一个消费者消费</p><h4 id="发布-订阅模型" tabindex="-1"><a class="header-anchor" href="#发布-订阅模型"><span>发布/订阅模型</span></a></h4><p>为了解决<strong>一个消息只能被一个消费者消费的问题</strong>，于是便有了发布/订阅模型，该模型是将消息发往一个 <mark>Topic</mark> 即主题中，订阅了这个主题就能消费这个消息。</p><p>比喻一下，<strong>发布/订阅模式</strong>就等于我们都加入了一个群聊中，我发一条消息，加入了这个群聊的人都可以收到这条消息。<strong>队列模型</strong>就是一对一聊天，我给你发消息只可以在和你的聊天窗口中，不会出现在其他人窗口去。</p><p>那么又有人说，那我一对一聊天将这一条消息发送给很多个人不一样的道理吗？是的。通过全队列全量存储相同的消息，即数据冗余可以实现一条消息被多个消费者消费。<code>RabbitMQ</code> 就是采用队列模型，通过Exchange模块来将消息发送至多个队列，解决一条消息多个消费者消费的问题。</p><h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h4><p><code>RabbitMQ</code>采用队列模型，<code>RocketMQ</code>和<code>Kafka</code>采用发布/订阅模型。</p><h2 id="发布-订阅模型-1" tabindex="-1"><a class="header-anchor" href="#发布-订阅模型-1"><span>发布/订阅模型</span></a></h2><figure><img src="https://pic.imgdb.cn/item/663c307c0ea9cb1403c294b5.png" alt="mq三大组成" tabindex="0" loading="lazy"><figcaption>mq三大组成</figcaption></figure><p><strong>一般称消息发送方为<code>Producer</code>，接收消息方为<code>Consumer</code>，消息队列服务端为<code>Broker</code>。</strong></p><p>消息从<code>Producer</code>发往<code>Broker</code>，<code>Broker</code>将消息存到本地，然后<code>Consumer</code>从<code>Broker</code>拉取消息，或者<code>Broker</code>推送消息到<code>Consumer</code>，然后消费。</p><p>为了提高并发度，往往发布/订阅模型还会引入<strong>队列</strong>或者<strong>分区</strong>的概念。消息是发往一个主题(Topic)下的某个队列或者分区中。<code>RocketMQ</code>中叫队列，<code>KafKa</code>中叫分区，本质一样。 例如，某个主题下有5个队列，那么这个主题的并发度为5，同时可以支持5个消费者并行消费该主题中的消息。一般都是采用轮询或者hash算法将消息费发到主题的不同队列中。</p><p><strong>消费者一般都有组的概念 Consumer Group，即消费者都是属于某个消费组，一条消息会发往多个订阅了这个主题的消费组。</strong></p><figure><img src="https://pic.imgdb.cn/item/663c77080ea9cb14032d8ae9.png" alt="mq-group" tabindex="0" loading="lazy"><figcaption>mq-group</figcaption></figure><p>一条消息在Broker中只会有一份，每个消费组有自己的offset即消费点位标识消费到的位置，消费点位前说明已经消费过了。消费点位是队列级别的，每个消费组都会维护订阅的Topic下的每个队列的offset。</p><h4 id="如何保证消息不丢失" tabindex="-1"><a class="header-anchor" href="#如何保证消息不丢失"><span>如何保证消息不丢失</span></a></h4><p>消息队列处理消息一般有三个阶段：<strong>生产消息、存储消息和消费消息</strong>。</p><ul><li><strong>生产消息</strong> 生产者发送消息到<code>Broker</code>，需要处理<code>Broker</code>的响应，同步和异步回调都需要做好<code>Try-catch</code>，妥善处理响应，如果<code>Broker</code>返回写入失败等错误消息，需要重试，多次发送失败需要作报警。</li><li><strong>存储消息</strong> 存储消息需要在刷盘之后在响应给生产者。为什么要这样呢？如果消息写入缓存就响应，那么机器突然断电消息就没了，而生产者以为发送成功了。 如果<code>Broker</code>是集群部署，有多副本机制，消息不仅要写入当前的<code>Broker</code>中，还要写入副本机中，至少写入两台后再给生产者响应。</li></ul><blockquote><p>刷盘：并不是每次收到数据就会立即写入磁盘，而是优先读取到缓冲区，将缓冲区的数据写到磁盘的过程叫刷盘。</p></blockquote><ul><li><strong>消费消息</strong> 误区：消费者拿到消息之后直接存入内存队列就返回给<code>Broker</code>消费成功。因为你要考虑到消息放在内存之后就宕机了怎么办。 正确做法：<strong>应该在消费者真正执行完业务逻辑之后，再发送<code>Broker</code>消费成功</strong>，这才是真正的消费了。</li></ul><h4 id="如何处理重复消息" tabindex="-1"><a class="header-anchor" href="#如何处理重复消息"><span>如何处理重复消息</span></a></h4><ul><li><strong>重复消息是如何出现的？</strong></li></ul><ol><li>生产者将消息放入<code>Broker</code>等待<code>Broker</code>的响应时，由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。</li><li>假设消费者拿到消息消费，业务逻辑走完了，事物提交了，此时要更新<code>Consumer offest </code>，然后消费者挂了，另一个消费者顶上，此时<code>Consumer offest</code>没有更新，于是又拿一遍刚才的消息，业务又执行一遍。</li></ol><ul><li><strong>如何解决重复消费消息？幂等</strong>。</li></ul><ol><li>通过version即版本号控制，对比消息中的版本号和数据库中的版本号</li><li>记录关键的key。如订单ID等。</li></ol><blockquote><p>什么是幂等？理解为同样的参数多次调用同一个接口和调用一次产生的结果是一致的。</p></blockquote><h4 id="如何保证消息的有序性" tabindex="-1"><a class="header-anchor" href="#如何保证消息的有序性"><span>如何保证消息的有序性</span></a></h4><ul><li>全局有序（一般情况下不需要）</li></ul><p>要保证全局有序，首先只能由一个生产者往Topic发送消息，并且一个<code>Topic</code>内部只能由一个队列（分区）。消费者也必须单线程消费这个队列。但即使是同步<code>Mysql Binlog</code> 也只需要保证单表消息有序。</p><ul><li>部分有序（大部分的情况）</li></ul><figure><img src="https://pic.imgdb.cn/item/663c8a450ea9cb14034a4e5c.png" alt="mq-queue" tabindex="0" loading="lazy"><figcaption>mq-queue</figcaption></figure><p>将<code>Topic</code>内部划分为我们需要的队列数，消息通过特定的策略发往固定的队列中，每个队列对应一个单线程处理的消费者，这样完成了部分有序的需求，又可以通过队列数量的并发提高消息处理效率。</p><h4 id="如何处理消息堆积" tabindex="-1"><a class="header-anchor" href="#如何处理消息堆积"><span>如何处理消息堆积</span></a></h4><ul><li><strong>原因</strong>：生产者的生产速度与消费者的速度不匹配。</li><li><strong>方案</strong>：先定位<strong>消费慢</strong>的原因，如果是bug则处理bug；如果是本身消费能力较弱，优化小消费逻辑，比如之前是一条一条消费处理的，优化为批量处理；水平扩容，增加<code>Topic</code>队列数和消费者数。<strong>注意队列数一定要增加</strong>，不然新增加的消费者是没东西消费的。<strong>一个Topic中，一个队列只会分配给一个消费者</strong>。</li><li>你是将接受到的消息写入内存队列之后，然后就返回响应给<code>Broker</code>，然后多线程向内存队列消费消息，假设此时消费者宕机之后内存队列里还未消费的消息也就丢了。</li></ul><h3 id="如何写个消息中间件" tabindex="-1"><a class="header-anchor" href="#如何写个消息中间件"><span>如何写个消息中间件</span></a></h3><pre><code>1. 首先需要明确地提出消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心；
2. 简述下消息中间件数据流转过程，无非就是生产者生产消息，发送至Broker，Broker可以暂缓消息，然后消费者再从Broker获取消息，用于消费；
3. 而注册中心用于服务的发现包括：Broker的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心；
4. 然后开始讲述实现要点：各个模块的通信基于Netty然后自定义协议来实现，注册中心可以利用Zookeeper、consul、eureka、nacos等等，**也可以像RockerMQ自己实现简单的namesrv；**
5. 为了考虑扩容和整体的性能，采用分布式思想，就像kafka一样采取分区理念，一个Topic分为多个partition，并且为了保证数据可靠性，采取多副本存储，即Leader和follower，根据性能和数据可靠的权衡提供异步和同步的输盘存储；
6. 还可以利用选举算法保证Leader挂了之后follower可以顶上，保证消息队列的高可用；
7. 为了提供消息的可靠性，利用本地文件系统来存储消息，并且采用顺序写的方式来提高性能；
8. 根据消息队列的特性利用内存映射、零拷贝进一步提升性能，还可以利用像kafka这种批处理思想提高整体的吞吐量。
</code></pre>`,54)]))}const d=o(n,[["render",c],["__file","MQ.html.vue"]]),l=JSON.parse('{"path":"/develop-tool/MQ.html","title":"消息队列","lang":"zh-CN","frontmatter":{"title":"消息队列","icon":"comment-medical","category":["开发工具"],"tag":["tools"],"description":"MQ 什么是消息队列？ 维基百科: 在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。 简单概括就是：消息队列就是使用队列来通信的组件。 为什么需要消息队列？ 从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/develop-tool/MQ.html"}],["meta",{"property":"og:site_name","content":"CODER LIANG"}],["meta",{"property":"og:title","content":"消息队列"}],["meta",{"property":"og:description","content":"MQ 什么是消息队列？ 维基百科: 在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。 简单概括就是：消息队列就是使用队列来通信的组件。 为什么需要消息队列？ 从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://pic.imgdb.cn/item/663c307c0ea9cb1403c294b5.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-09T08:35:17.000Z"}],["meta",{"property":"article:tag","content":"tools"}],["meta",{"property":"article:modified_time","content":"2024-09-09T08:35:17.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列\\",\\"image\\":[\\"https://pic.imgdb.cn/item/663c307c0ea9cb1403c294b5.png\\",\\"https://pic.imgdb.cn/item/663c77080ea9cb14032d8ae9.png\\",\\"https://pic.imgdb.cn/item/663c8a450ea9cb14034a4e5c.png\\"],\\"dateModified\\":\\"2024-09-09T08:35:17.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Coder Liang\\",\\"url\\":\\"https://blog.csdn.net/Phone_1070333541?type=blog\\"}]}"]]},"headers":[{"level":2,"title":"什么是消息队列？","slug":"什么是消息队列","link":"#什么是消息队列","children":[]},{"level":2,"title":"为什么需要消息队列？","slug":"为什么需要消息队列","link":"#为什么需要消息队列","children":[]},{"level":2,"title":"消息队列两种模型","slug":"消息队列两种模型","link":"#消息队列两种模型","children":[]},{"level":2,"title":"发布/订阅模型","slug":"发布-订阅模型-1","link":"#发布-订阅模型-1","children":[{"level":3,"title":"如何写个消息中间件","slug":"如何写个消息中间件","link":"#如何写个消息中间件","children":[]}]}],"git":{"createdTime":1725870917000,"updatedTime":1725870917000,"contributors":[{"name":"liangxinglong","username":"liangxinglong","email":"16630935153@163.com","commits":1,"url":"https://github.com/liangxinglong"}]},"readingTime":{"minutes":8.95,"words":2686},"filePathRelative":"develop-tool/MQ.md","localizedDate":"2024年9月9日","excerpt":"\\n<h2>什么是消息队列？</h2>\\n<blockquote>\\n<p>维基百科: 在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。</p>\\n</blockquote>\\n<p>简单概括就是：消息队列就是使用队列来通信的组件。</p>\\n<h2>为什么需要消息队列？</h2>\\n<p>从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要某个东西用来应用解耦服务之间的关系，控制资源合理和时的使用以及缓冲流量高峰等等。\\n所以消息队列就这么诞生了，常用于：<strong>异步处理</strong>、<strong>服务解耦</strong>、<strong>流量控制</strong>。</p>","autoDesc":true}');export{d as comp,l as data};
